<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Lode Runner par Charles Morin et Andrew Aboujaoudé</title>
  <link href='https://fonts.googleapis.com/css?family=Audiowide' rel='stylesheet'>
  <!-- Code JavaScript local -->
  <script type="text/javascript">
	let objCanvas = null;
	let objC2D = null;
	let objCycleAnimation = null;

	//Constante
	const CELL_HEIGHT = 17;
	const CELL_WIDTH = 28;
	const CELL_DIMENSION = 32;

	//Images
	let imgNiveau = null;
	let imgEchelle = null;
	let imgBrique = null;
	let imgBeton = null;
	let imgCoffre = null;

	//Objets
	let p = null; //LodeRunner
	let objGUI = null; //Interface d'affichage des points, du temps, du niveau et des vies.

	//Niveau
	let tabBlocs = new Array();

	//DEBUG mode
	let binDebug = false;

	function initAnimation() {
        objCanvas = document.getElementById('monCanvas');
		objCanvas.focus();
        objC2D = objCanvas.getContext('2d');
		initSprites();
		initNiveau();
		initGUI();
		initLodeRunner();
	    dessiner(); // Dessiner une première fois
        animer();  // animer
    }

	function initGUI() {
		objGUI = new Object;
		objGUI.intScore = 0;
		objGUI.objDate = new Date();
		objGUI.intTime = 0;
		objGUI.intNiveau = 1;
		objGUI.intVies = 5;
	}

	function initLodeRunner() {
		let imgLodeRunner = new Image();
		imgLodeRunner.src = 'lodeRunner.png';

		p = new Object;
		//Sprite de LodeRunner
		p.sprite = imgLodeRunner;
		//Coordonnées
		p.fltX = (CELL_WIDTH * CELL_DIMENSION) / 2;
		p.fltY = ((CELL_HEIGHT - 3) * CELL_DIMENSION);
		//Position de l'image dans la grillle
		p.ligne = (CELL_WIDTH / 2);
		p.colonne = CELL_HEIGHT - 3;
		//Vitesse
		p.fltVitesse = 8;
		//State
		p.direction = {gauche: true, droite: true, haut: true, bas: true, tomber: false};
		p.orientation = {gauche: true, droite: false, haut: false, bas: false, tomber: false};

		//Artefacts(Inutile)
		p.binMarcher = true;
		p.gridPos = {LIGNE: (CELL_WIDTH / 2), COLONNE: CELL_HEIGHT - 3};
		p.fltX2 = p.fltX + CELL_DIMENSION;
		p.fltY2 = p.fltY + CELL_DIMENSION;

	}

	/**
	 * Initialiser le niveau
	 * MAP CONVERT rgb
	 *BRICK = RED(255, 0, 0)
	 *COFFRE = JAUNE(225, 225, 0)
     *ECHELLE = BRUN(130, 70, 25)
	 *BARRIER = BLUE(0, 0, 255)
	 * -1 = vide
	 * 0  = échelle
	 * 1 = brique
	 * 2 = coffre
	 * 3 = barrier
	 */
	function initNiveau() {
		objC2D.save();
		//Charger l'image du niveau

		imgNiveau = new Image();
		imgNiveau.src = 'niveauTest.png';
		let tableauTemp = new Array();

		imgNiveau.onload = function() {
			//Dessiner l'image sur le canvas
			objC2D.drawImage(imgNiveau, 0, 0);

			//Convertir l'image en un tableau de pixels
			const objPixels = objC2D.getImageData(0, 0, CELL_WIDTH, CELL_HEIGHT);

			//Lire les pixels
			let cell_id = 0;
			for(let p = 0; p < objPixels.data.length; p += 4) {
						
				const RED = objPixels.data[p];
				const GREEN = objPixels.data[p + 1];
				const BLUE = objPixels.data[p + 2];

				//console.log("RGB("+RED+", "+GREEN+", "+BLUE+")");
				//Si le pixel est Brun(130, 70, 25) alors la case est une échelle
				if((RED >= 125 && RED <= 135) && (GREEN >= 65 && GREEN <= 75) && (BLUE >= 20 && BLUE <= 30))
					tableauTemp[cell_id] = creerBloc(0);
				//Si le pixel est Rouge(255, 0, 0) alors la case est une brique
				else if(RED >= 254 && GREEN <= 5 && BLUE <= 5)
					tableauTemp[cell_id]  = creerBloc(1);
				//Si le pixel est Jaune(225, 225, 0) alors la case est un coffre
				else if((RED >= 220 && RED <= 230) && (GREEN >= 220 && GREEN <= 230) && BLUE <= 5)
					tableauTemp[cell_id]  = creerBloc(2);
				else if(RED <= 5 && GREEN <= 5 && BLUE >= 254)
					tableauTemp[cell_id]  = creerBloc(3);
				//Sinon la case est vide
				else 
					tableauTemp[cell_id]  = creerBloc(-1);
				cell_id++;
			}

			console.log("Tableau remplit -> Size: "+tableauTemp.length+" [32x32] Blocs");
			//console.log("Size: "+tableauTemp.length);

			//Séparer le tableau en un tableau a 2 dimensions
			let ligne = 0;
			while(tableauTemp.length) {
				tabBlocs[ligne] = tableauTemp.splice(0, 28);
				ligne++;
			}
			//Données coordonnées
			//j * 32, i * 32
			for(let i = 0; i < tabBlocs.length; i++) {
				for(let j = 0; j < tabBlocs[i].length; j++) {
					tabBlocs[i][j].x = j * CELL_DIMENSION;
					tabBlocs[i][j].x2 = tabBlocs[i][j].x + CELL_DIMENSION;
					tabBlocs[i][j].y = i * CELL_DIMENSION;
					tabBlocs[i][j].y2 = tabBlocs[i][j].y + CELL_DIMENSION;
				}
			}
			console.log("Tableau Séparé:");
			console.log("Ancien Tableau: "+tableauTemp.length);
			console.log("Nouveau Tableau: "+tabBlocs.length);
			//console.log(tabNiveau[1][2]);
			effacerDessin();
		}
	}

	/**
	 *Function qui créer un objet bloc en fonction du bloc_id qu'il recoit en paramètres
	 *@param {number} bloc_id L'id du bloc que la fonction doit créer
	 *@return un objet représentant un bloc du niveau.
	 **/
	function creerBloc(bloc_id) {
		let objBloc = new Object();

		//sprite image
		let strNomBlock = "";
		let objImage = null;
		let isSolid = false;
		switch(bloc_id) {
			case 0:
				strNomBlock = "ECHELLE";
				objImage = imgEchelle;
				break;
			case 1:
				strNomBlock = "BRIQUE";
				objImage = imgBrique;
				isSolid = true;
				break;
			case 2:
				strNomBlock = "COFFRE";
				objImage = imgCoffre;
				break;
			case 3:
				strNomBlock = "BETON";
				objImage = imgBeton;
				isSolid = true;
				break;
			default:
				strNomBlock = "VIDE";
				objImage = new Image();
				isSolid = false;
				break;
		}
		//Nom du block
		objBloc.strNom = strNomBlock;
		//sprite image
		objBloc.sprite = objImage;
		//SOLID BLOCK
		objBloc.isSolid = isSolid;
		//Coordonnées/Hitbox
		objBloc.x;
		objBloc.x2;
		objBloc.y;
		objBloc.y2;

	return objBloc;

	}

	/**
     *Fonction qui charge toutes les images nécèssaires au jeu
	 */
	function initSprites() {
		imgEchelle = new Image();
		imgEchelle.src = 'echelle.png';
		imgBrique = new Image();
		imgBrique.src = 'brique.png';
		imgCoffre = new Image();
		imgCoffre.src = 'coffre.png';
		imgBeton = new Image();
		imgBeton.src = 'beton.png';
	}

    // Un cycle d'animation	
    function animer() {
        // Requête pour le prochain cycle
        objCycleAnimation = requestAnimationFrame(animer);

		// Le cycle d'animation
		effacerDessin();
		mettreAjourAnimation();
		dessiner();
	}

    // Arrêter l'animation
	function arreterAnimation() {
	    if (objCycleAnimation != null)
	        cancelAnimationFrame(objCycleAnimation);
		objCycleAnimation = null;
	}
		
	// Pour effacer le dessin
	function effacerDessin() {
		objC2D.clearRect(0,0, objCanvas.width, objCanvas.height); 
	}
	
	// Pour mettre à jour l'animation
	function mettreAjourAnimation() {
		//Update Gui
		mettreAjourGUI();
		mettreAjourLodeRunner();
	}

	function mettreAjourLodeRunner() {
		//Mettre a jour Ligne et Colonne -> gridPos
		p.gridPos = getGridPos(p.fltX, p.fltY);
		p.ligne = getGridPos(p.fltX, p.fltY).LIGNE;
		p.colonne = getGridPos(p.fltX, p.fltY).COLONNE;
		p.fltX2 = p.fltX + CELL_DIMENSION;
		p.fltY2 = p.fltY + CELL_DIMENSION;
		p.direction = checkDirection(p);

		//Tomber
		/* 
		if(!p.binMarcher) {
			if(p.fltY % CELL_DIMENSION == 0 && tabBlocs[Math.ceil(p.gridPos.LIGNE + 1)][Math.ceil(p.gridPos.COLONNE)].strNom != 'VIDE') {
				p.binMarcher = true;
			}
			else 
				p.fltY += 4;
		}
		else if(p.fltY % CELL_DIMENSION == 0) {
			if((p.binGauche
			 && tabBlocs[Math.ceil(p.gridPos.LIGNE)][Math.ceil(p.gridPos.COLONNE)].strNom == 'VIDE'
			 && tabBlocs[Math.ceil(p.gridPos.LIGNE + 1)][Math.ceil(p.gridPos.COLONNE)].strNom == 'VIDE')
			  || 
			(!p.binGauche
			 && tabBlocs[Math.ceil(p.gridPos.LIGNE)][Math.floor(p.gridPos.COLONNE)].strNom == 'VIDE'
			 && tabBlocs[Math.ceil(p.gridPos.LIGNE + 1)][Math.floor(p.gridPos.COLONNE)].strNom == 'VIDE')) {
				p.binMarcher = false;
			}
		} 
		*/
	}

	function mettreAjourGUI() {
		//update Temps
		mettreAjourTemps();
	}

	function mettreAjourTemps() {
    	let objDate2 =  new Date();
        if(objGUI.objDate != null && objDate2 != null) {
            let msDifference = objDate2.getTime() - objGUI.objDate.getTime();
            objGUI.objDate = objDate2;
            objGUI.intTime += msDifference;
        }
	}

    // Pour dessiner
	function dessiner() {
		dessinerNiveau();
		dessinerGUI();
		if(binDebug)
			dessinerDebug();
		dessinerLodeRunner();
	}

	function dessinerLodeRunner() {		
		objC2D.save();
		
		//Marche à gauche
		if(p.orientation.gauche) {
			objC2D.drawImage(p.sprite, p.fltX, p.fltY);
		}
		//Marche a droite
		if(p.orientation.droite) {
			objC2D.translate(p.fltX + p.sprite.width, p.fltY);
			objC2D.scale(-1, 1);
			objC2D.drawImage(p.sprite, 0, 0);
		}
		//Monte ou descends
		if(p.orientation.haut || p.orientation.bas) {
			//TEMP SPRITE
			objC2D.drawImage(p.sprite, p.fltX, p.fltY);
		}
		//Tombe
		if(p.orientation.tomber) {
			//TEMP SPRITE
			objC2D.drawImage(p.sprite, p.fltX, p.fltY);
		}

		//Creuse un trou
		objC2D.restore();
	}

	function dessinerGUI() {
		objC2D.save();
		//Dessiner le background du GUI
		objC2D.fillStyle = 'black';
		objC2D.fillRect(0, CELL_DIMENSION*CELL_HEIGHT, objCanvas.width, objCanvas.height);
		
		objC2D.font = '20px Audiowide';
		objC2D.fillStyle = 'orange';
		//Afficher Score
			//MAX_SCORE est 9 999 999
		objC2D.fillText(getScoreFormat(objGUI.intScore), 50, objCanvas.height - CELL_DIMENSION);
		//Afficher Temps
		objC2D.fillText("Temps: "+getTimeText(objGUI.intTime), 300, objCanvas.height - CELL_DIMENSION);
		//Afficher Niveau
		objC2D.fillText("Niveau: "+objGUI.intNiveau, 500, objCanvas.height - CELL_DIMENSION);
		//Afficher Vie
		objC2D.fillText("Vies: "+objGUI.intVies, 650, objCanvas.height - CELL_DIMENSION);
		objC2D.restore();
	}

	function dessinerNiveau() {
		objC2D.save();
		dessinerBackground();
		for(let i = 0; i < tabBlocs.length; i++) {
			for(let j = 0; j < tabBlocs[i].length; j++) {
				objC2D.drawImage(tabBlocs[i][j].sprite, tabBlocs[i][j].x, tabBlocs[i][j].y);
			}
		}
		objC2D.restore();
	}

	function dessinerBackground() {
		objC2D.save();
		objC2D.fillStyle = 'black';
		objC2D.fillRect(0, 0, objCanvas.width, objCanvas.height);
		objC2D.restore();
	}

	function dessinerDebug() {
		objC2D.save();
		//GRID
		//HITBOX BRIQUE, COFFRE, ECHELLE, BARRIER, BARRE
		for(let i = 0; i < tabBlocs.length; i++) {
			for(let j = 0; j < tabBlocs[i].length; j++) {
					if(tabBlocs[i][j].strNom == 'VIDE')
						objC2D.strokeStyle = 'green';
					else if(tabBlocs[i][j].strNom == 'COFFRE')
						objC2D.strokeStyle = 'yellow';
					else if(tabBlocs[i][j].strNom == 'ECHELLE')
						objC2D.strokeStyle = 'red';
					else if(tabBlocs[i][j].strNom == 'BRIQUE' || tabBlocs[i][j].strNom == 'BETON')
						objC2D.strokeStyle = 'cyan';

					objC2D.linewidth = 2;
					objC2D.strokeRect(tabBlocs[i][j].x, tabBlocs[i][j].y, CELL_DIMENSION, CELL_DIMENSION);
			}
		}
		
		//INFORMATION LODE RUNNER
		objC2D.font = '15px Arial';
		objC2D.fillStyle = 'pink';
		objC2D.fillText("X: "+p.fltX+" Y: "+p.fltY, 0, 15);
		objC2D.fillText("X2: "+p.fltX2+" Y2: "+p.fltY2, 0, 30);
		objC2D.fillText("L: "+p.ligne+" C: "+p.colonne, 0, 45);
		objC2D.fillText("G: "+p.direction.gauche+" D: "+p.direction.droite, 0, 60);
		objC2D.fillText("H: "+p.direction.haut+" B: "+p.direction.bas, 0, 75);
		objC2D.fillText("O-G: "+p.orientation.gauche+"  O-D: "+p.orientation.droite, 0, 90);
		objC2D.fillText("O-H: "+p.orientation.haut+" O-B: "+p.orientation.bas, 0, 105);

		//HITBOX LODE RUNNER
		objC2D.linewidth = 50;
		objC2D.strokeStyle = 'blue';
		objC2D.strokeRect(p.fltX, p.fltY, CELL_DIMENSION, CELL_DIMENSION);
		//SCAN HITBOX LODE RUNNER

		//HITBOX GUARD
		objC2D.restore();
	}

	function getScoreFormat(intScore) {
		let strPadding = "0000000";
		return "Score: "+strPadding.substring(0, (strPadding.length - intScore.toString().length)) + intScore.toString();
	}

	function getTimeText(ms) {
          let timePassed = new Date(0);
          timePassed.setHours(0, 0, 0, ms);

          const STR_MINUTES = (timePassed.getMinutes() < 10) ? "0"+timePassed.getMinutes():timePassed.getMinutes();
          const STR_SECONDS = (timePassed.getSeconds() < 10) ? "0"+timePassed.getSeconds():timePassed.getSeconds();

          return STR_MINUTES+":"+STR_SECONDS;;
      }

	function getGridPos(fltX, fltY) {
		return { LIGNE: fltY / CELL_DIMENSION, COLONNE: fltX / CELL_DIMENSION};
	}

	function changeOrientation(personnage, strOrientation) {
		personnage.orientation.gauche = false;
		personnage.orientation.droite = false;
		personnage.orientation.haut = false;
		personnage.orientation.bas = false;
		personnage.orientation.tomber = false;
		personnage["orientation"][strOrientation] = true;
	}

	/**
	 *Scan dans les 4 directions autours du personnage en paramètres
	  afin de savoir s'il y a la permission de faire les actions suivantes
	  -Marcher à gauche
	  -Marcher à droite
	  -Monter en haut
	  -Descendre en bas
	  -Doit Tomber
	  Cette fonction met à jour la propriété "direction" du character "c"
	 */
	function checkDirection(c) {
		let binGauche = false;
		let binDroite = false;
		let binHaut = false;
		let binBas = false;
		let binTomber = false;

		//GAUCHE
		//Regarder si le personnage n'a pas franchi la limite à gauche
		if(c.fltX > 0) {
			//Sélectionner les blocs à gauche du personnage
			let tabBlocsGauche = [
				tabBlocs[Math.floor(c.ligne)][Math.ceil(c.colonne) - 1],
				tabBlocs[Math.ceil(c.ligne)][Math.ceil(c.colonne) - 1]
			];
			for(let i = 0; i < tabBlocsGauche.length; i++) {
				//Regarde si les blocs à gauche sont solides
				if(!tabBlocsGauche[i].isSolid)
					binGauche = true;
			}
		}

		//DROITE
		//Regarder si le personnage n'a pas franchi la limite à droite
		if(c.fltX + CELL_DIMENSION < objCanvas.width) {
			//Sélectionner les blocs à droite du personnage
			let tabBlocsDroite = [
				tabBlocs[Math.floor(c.ligne)][Math.floor(c.colonne) + 1],
				tabBlocs[Math.ceil(c.ligne)][Math.floor(c.colonne) + 1]
			];
			for(let i = 0; i < tabBlocsDroite.length; i++) {
				//Regarde si les blocs à droite sont solides
				if(!tabBlocsDroite[i].isSolid)
					binDroite = true;
			}
		}

		//HAUT
		//Regarder si le personnage n'a pas franchi la limite en haut
		if(c.fltY > 0) {
			//Regarder si le joueur est sur un block complet? (Horizontalement)
			if(c.colonne - parseInt(c.colonne) == 0) {
				//Regarder si le joueur est sur une echelle?
				if(tabBlocs[Math.ceil(c.ligne)][c.colonne].strNom == 'ECHELLE') {
					//Regarder si le bloc au dessus du joueur est un bloc vide ou une echelle?
					if(tabBlocs[Math.ceil(c.ligne - 1)][c.colonne].strNom == 'ECHELLE' || tabBlocs[Math.ceil(c.ligne - 1)][c.colonne].strNom == 'VIDE') {
						binHaut = true;
					}
				}
			}
		}

		//BAS
		//Regarder si le personnage n'a pas franchi la limite en haut
		if(c.fltY + CELL_DIMENSION < (CELL_HEIGHT * CELL_DIMENSION)) {
			//Regarder si le joueur est sur un block complet? (Horizontalement)
			if(c.colonne - parseInt(c.colonne) == 0) {
				//Regarder si le joueur est sur une echelle ou dans le vide?
				if(tabBlocs[Math.floor(c.ligne)][c.colonne].strNom == 'ECHELLE' || tabBlocs[Math.floor(c.ligne)][c.colonne].strNom == 'VIDE') {
					//Regarder si le bloc au dessous du joueur est une echelle? Q: Est-ce qu'on permet de tomber si il y a du vide en dessous d'une echelle?
					if(tabBlocs[Math.floor(c.ligne + 1)][c.colonne].strNom == 'ECHELLE') {
						binBas = true;
					}
				}
			}
		}

		//TOMBER

		return {gauche: binGauche, droite: binDroite, haut: binHaut, bas: binBas};
	}

	/**
	 *Gère toute les entrées faites sur le clavier par le joueur
	*/
	function gererControle() {
		//DEBUG #TODO supprimer à la fin
		console.log("KeyCode -> "+event.keyCode);

		//Debug F3
		if(event.keyCode == 114) {
			if(binDebug)
				binDebug = false;
			else if(!binDebug)
				binDebug = true;
		}

		//Bouger droite	
		if(event.keyCode == 39) {
			if(p.direction.droite) {
				if(p.orientation.droite)
					p.fltX += p.fltVitesse;
				else
					changeOrientation(p, "droite");
			}
		}
		//Bouger gauche
		if(event.keyCode == 37) {
			if(p.direction.gauche) {
				if(p.orientation.gauche && p.fltX >= 0)
					p.fltX -= p.fltVitesse;
				else
					changeOrientation(p, "gauche");
			}
		}
		//Monter
		if(event.keyCode == 38) {
			if(p.direction.haut) {
				if(p.orientation.haut)
					p.fltY -= p.fltVitesse;
				else
					changeOrientation(p, "haut");
			}
		}
		//Descendre
		if(event.keyCode == 40) {
			if(p.direction.bas) {
				if(p.orientation.bas)
					p.fltY += p.fltVitesse;
				else
					changeOrientation(p, "bas");
			}
		}
	}

	function gererControleOLD() {
		console.log("KeyCode -> "+event.keyCode);

		if(p.binMarcher) { 
			
			const LIGNE = Math.ceil(p.gridPos.LIGNE);
			const COLONNE = Math.ceil(p.gridPos.COLONNE);
			//Bouger droite	
			if(event.keyCode == 39) {
				if(!p.binGauche 
					&& p.fltY % CELL_DIMENSION == 0
					&& p.fltX2 <= objCanvas.width 
					&& !tabBlocs[LIGNE][Math.floor(p.gridPos.COLONNE) + 1].isSolid) {
					p.fltX += p.fltVitesse;
					p.fltX2 = p.fltX + CELL_DIMENSION;
				}
				p.binGauche = false;
			}
			//Bouger gauche
			if(event.keyCode == 37) { 
				if(p.binGauche 
					&& p.fltY % CELL_DIMENSION == 0 
					&& p.fltX >= 0 
					&& !tabBlocs[LIGNE][COLONNE - 1].isSolid) {
					p.fltX -= p.fltVitesse;
					p.fltX2 = p.fltX + CELL_DIMENSION;
				}
				p.binGauche = true;
			}
			//Monter
			if(event.keyCode == 38) {
				if(p.fltX % CELL_DIMENSION == 0 
					&& p.fltY >= 0
					&& tabBlocs[LIGNE][COLONNE].strNom == 'ECHELLE'
					&& !tabBlocs[LIGNE - 1][COLONNE].isSolid) {
					p.fltY -= p.fltVitesse;
					p.fltY2 = p.fltY + CELL_DIMENSION;
				}
			}
			//Descendre
			if(event.keyCode == 40) {
				if(p.fltX % CELL_DIMENSION == 0 
					&& tabBlocs[LIGNE][COLONNE].strNom == 'ECHELLE' 
					&& !tabBlocs[Math.floor(p.gridPos.LIGNE) + 1][COLONNE].isSolid) {
					p.fltY += p.fltVitesse;
					p.fltY2 = p.fltY + CELL_DIMENSION;
				}
			}
			//Détruire
		}
	}

   </script>
</head>

<body onload="initAnimation()"> 
	<canvas id="monCanvas" width="896" height="608" tabIndex="1" onkeydown="gererControle(); return false">
		Votre navigateur ne supporte pas la balise canvas
	</canvas>
</body>

</html>